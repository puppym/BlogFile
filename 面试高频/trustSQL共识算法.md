## 共识算法

理解：区块链中共识的本质就是通过数学方法降低各个节点之间的信任成本，是的各个节点的数据顺序达成一致状态。

![img](https://pic1.zhimg.com/80/v2-1b29af254f0cc338876f232e32415878_720w.jpg)

- 公链：公链不断需要考虑网络中存在故障节点，还需要考虑作恶节点，这一点和联盟链是类似的。和联盟链最大的区别就是，公链中的节点可以很自由的加入或者退出，不需要严格的验证和审核。

- 联盟链：联盟链中，经典的代表项目是 Hyperledger 组织下的 Fabric 项目， Fabric0.6 版本使用的就是 pbft 算法。联盟链的适用环境除了需要考虑集群中存在故障节点，还需要考虑集群中存在作恶节点。对于联盟链，每个新加入的节点都是需要验证和审核的。

- 私链：私链的共识算法即区块链这个概念还没普及时的传统分布式系统里的共识算法，比如 zookeeper 的 zab 协议，就是类 paxos 算法的一种。私链的适用环境一般是不考虑集群中存在作恶节点，只考虑因为系统或者网络原因导致的故障节点。

  

### raft

RAFT算法包含三种角色，分别是：跟随者（follower），候选人（candidate）和领导者（leader）。集群中的一个节点在某一时刻只能是这三种状态的其中一种，这三种角色可以随着时间和条件的变化而互相转换。

RAFT算法主要有两个过程：一个过程是领导者选举，另一个过程是日志复制，其中日志复制过程会分记录日志和提交数据两个阶段。RAFT算法支持最大的容错故障节点是（N-1）/2，其中N为集群中总的节点数量。

动画主要包含三部分内容，第一部分介绍简单版的领导者选举和日志复制的过程，第二部分内容介绍详细版的领导者选举和日志复制的过程，第三部分内容介绍的是如果遇到网络分区（脑裂），raft 算法是如何恢复网络一致的。有兴趣的朋友可以结合这个动画来更好的理解raft算法。[raft动画](https://link.zhihu.com/?target=http%3A//thesecretlivesofdata.com/raft/)

leader选举。当follower没有受到leader的信息时，会变成candidate向其它节点发送信息，其它节点回复信息后变成leader。

在raft有两个超时设置控制选举。

1. 选举超时。follower等待直到变成一个candidate的时间。选举超时是任意的一般为150ms和300ms。一旦某一结点的选举超时到达就会变成一个candidate，并且开始选举期。首先为节点为自己投票，然后发送投票请求给其它节点。如果收到消息的节点在该周期内没有投过票，那么就会投票该节点，然后投票节点重置自己的选举超时。然后候选节点收到消息后变成leader。然后leader发送`Append entries messages`给followers，这些消息按照心跳超时间断的被发送。该选举周期将持续直到follower停止接收心跳信息成为一个candidate。

2. 重新选举：leader dump，按照上的的过程，一个follower称为candiate，向其它节点发送投票请求后成为leader（成为leader需要获取大部分的投票，每个选举周期只能由一个leader被选举）。
3. 如果两个节点同时变成candiate，然后发送投票请求，如果两个节点的票数相同，则再来一轮周期，之后再发送投票请求。直到一个节点的投票数最大为止。

日志复制分为记录日志和提交数据两个阶段。这两个阶段leader都会向follower发送消息，执行对应的动作。

1. 首先客户端向leader发送set请求，leader记录set请求，并且在下一个心跳发送该change。
2. 一旦大多数follower节点承认该change，然后leader会commit该change。并且向follower和client发送消息，follower会commit上述更改。client继续给leader发送change消息，继续执行上述过程。

raft甚至能够在网络分区时刻保持一致性。当分区之后，每个分区会选举出leader，然后在小的分区里面维持自己的分区一致性。每个分区给一个客户端，但是只有一个分区的更改会commit，其余分区的更改会提交但是不会commit。当分区消失时，未commit的分区会按照最高的更改复制其日志，然后更改本节点的信息。



### PBFT

该算法在保证活性和安全性的前提下提供了（n-1）/3的容错性。主要实现的有拜占庭容错的NFS文件系统。Hyperledger组织下的Fabric项目使用的是该算法。**最大故障和容错节点数：3f+1<=N**

PBFT算法假设节点间的交互在异步网络。简单地说，同步网络指一个网络节点在有限时间内能接收到其他网络节点的消息，异步网络不存在这样的假设：存在发送消息失败，消息延迟，重复消息以及消息错序。论文提到使用PBFT算法实现的NFS服务，性能也只在原有服务的基础上下降3%。

对于 pbft 算法，因为 pbft 算法的除了需要支持容错故障节点之外，还需要支持容错作恶节点。假设集群节点数为 N，有问题的节点为 f。有问题的节点中，可以既是故障节点，也可以是作恶节点，或者只是故障节点或者只是作恶节点。那么会产生以下两种极端情况：

1. 第一种情况，f 个有问题节点既是故障节点，又是作恶节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。也就是说这种情况支持的最大容错节点数量是 （n-1）/2。
2. 第二种情况，故障节点和作恶节点都是不同的节点。那么就会有 f 个问题节点和 f 个故障节点，当发现节点是问题节点后，会被集群排除在外，剩下 f 个故障节点，那么根据小数服从多数的原则，集群里正常节点只需要比f个节点再多一个节点，即 f+1 个节点，确节点的数量就会比故障节点数量多，那么集群就能达成共识。所以，所有类型的节点数量加起来就是 f+1 个正确节点，f个故障节点和f个问题节点，即 3f+1=n。

#### 总体流程如下:

pbft 算法的基本流程主要有以下四步：

1. 客户端发送请求给主节点 
2. 主节点广播请求给其它节点，节点执行 pbft 算法的三阶段共识流程。
3. 节点处理完三阶段流程后，返回消息给客户端。
4. 客户端收到来自 f+1 个节点的相同消息后，代表共识已经正确完成。

为什么收到 f+1 个节点的相同消息后就代表共识已经正确完成？从上一小节的推导里可知，无论是最好的情况还是最坏的情况，如果客户端收到 f+1 个节点的相同消息，那么就代表有足够多的正确节点已全部达成共识并处理完毕了。

#### 算法核心三阶段流程

![img](https://pic4.zhimg.com/80/v2-ab3bab245c17269625d7ebc56c3848c3_720w.jpg)

首先，客户端向主节点发起请求，主节点 0 收到客户端请求，会向其它节点发送 pre-prepare 消息，其它节点就收到了pre-prepare 消息，就开始了这个核心三阶段共识过程了。

1. Pre-prepare 阶段：节点收到 pre-prepare 消息后，会有两种选择，一种是接受，一种是不接受。什么时候才不接受主节点发来的 pre-prepare 消息呢？一种典型的情况就是如果一个节点接受到了一条 pre-pre 消息，消息里的 v 和 n 在之前收到里的消息是曾经出现过的，但是 d 和 m 却和之前的消息不一致，或者请求编号不在高低水位之间（高低水位的概念在下文会进行解释），这时候就会拒绝请求。拒绝的逻辑就是主节点不会发送两条具有相同的 v 和 n ，但 d 和 m 却不同的消息。
2. Prepare 阶段：节点同意请求后会向其它节点发送 prepare 消息。这里要注意一点，同一时刻不是只有一个节点在进行这个过程，可能有 n 个节点也在进行这个过程。因此节点是有可能收到其它节点发送的 prepare 消息的。在一定时间范围内，如果收到超过 2f 个不同节点的 prepare 消息，就代表 prepare 阶段已经完成。
3. Commit 阶段：于是进入 commit 阶段。向其它节点广播 commit 消息，同理，这个过程可能是有 n 个节点也在进行的。因此可能会收到其它节点发过来的 commit 消息，当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。

处理完毕后，节点会返回消息给客户端，这就是 pbft 算法的全部流程。为了更清晰的展现 这个过程和一些细节，下面以流程图来表示这个过程：

![img](https://pic4.zhimg.com/80/v2-451165a9d6de89d6b6f0e7468b71049b_720w.jpg)



#### checkpoint，stable checkpoint和高低水位

checkpoint 就是当前节点处理的最新请求序号。前文已经提到主节点收到请求是会给请求记录编号的。比如一个节点正在共识的一个请求编号是101，那么对于这个节点，它的 checkpoint 就是101。

stable checkpoint 就是大部分节点 （2f+1） 已经共识完成的最大请求序号。比如系统有 4 个节点，三个节点都已经共识完了的请求编号是 213 ，那么这个 213 就是 stable checkpoint 了。

stable checkpoint 的作用是最大目的减少内存占用。因为每个节点应该记录下之前曾经共识过什么请求，但如果一直记录下去，数据会越来越大，所以应该有一个机制来实现对数据的删除。那怎么删呢？很简单，比如现在的稳定检查点是 213 ，那么代表 213 号之前的记录已经共识过的了，所以之前的记录就可以删掉了。**stable checkpoint 是在 checkpoint之前**

高水位和低水位就是为了保证各个节点的共识数据存储速度达到一致。

#### ViewChange(视图更改)事件

当主节点挂了（超时无响应）或者从节点集体认为主节点是问题节点时，就会触发 ViewChange 事件， ViewChange 完成后，视图编号将会加 1 。下图展示 ViewChange 的三个阶段流程：

![img](https://pic2.zhimg.com/80/v2-ad76a4d2972a51caa904942ec168c96d_720w.jpg)

如图所示， viewchange 会有三个阶段，分别是 view-change ， view-change-ack 和 new-view 阶段。从节点认为主节点有问题时，会向其它节点发送 view-change 消息，当前存活的节点编号最小的节点将成为新的主节点。当新的主节点收到 2f 个其它节点的 view-change 消息，则证明有足够多人的节点认为主节点有问题，于是就会向其它节点广播 New-view 消息。注意：从节点不会发起 new-view 事件。对于主节点，发送 new-view 消息后会继续执行上个视图未处理完的请求，从 pre-prepare 阶段开始。其它节点验证 new-view 消息通过后，就会处理主节点发来的 pre-prepare 消息，这时执行的过程就是前面描述的 pbft 过程。到这时，正式进入 v+1 （视图编号加1）的时代了。

为了更清晰的展现 ViewChange 这个过程和一些细节，下面以流程图来表示这个过程：

![img](https://pic1.zhimg.com/80/v2-8a7ae919ae6e347bc8bd7cb46ef811e4_720w.jpg)

上图里红色字体部分的 O 集合会包含哪些 pre-prepare 消息呢？假设 O 集合里消息的编号范围：（min～max），则 Min 为 V 集合最小的 stable checkpoint ， Max 为 V 集合中最大序号的 prepare 消息。最后一步执行 O 集合里的 pre-preapare 消息，每条消息会有两种情况: 如果 max-min>0，则产生消息 <pre-prepare,v+1,n,d> ；如果 max-min=0，则产生消息 <pre-prepare,v+1,n,d(null)>。



### 两者的差异

![img](https://pic1.zhimg.com/80/v2-d1611f0fb63392a94c751d26ce66a660_720w.jpg)

差异主要有以下几点：

1. 算法通讯的时间复杂度。raft为O(n)，pbft为O(n^2)。

   * 对于 raft 算法，核心共识过程是日志复制这个过程，这个过程分两个阶段，一个是日志记录，一个是提交数据。两个过程都只需要领导者发送消息给跟随者节点，跟随者节点返回消息给领导者节点即可完成，跟随者节点之间是无需沟通的。所以如果集群总节点数为 n，对于日志记录阶段，通信次数为 n-1，对于提交数据阶段，通信次数也为 n-1，总通信次数为 2n-2，因此raft算法复杂度为O（n）。
   * 对于 pbft 算法，核心过程有三个阶段，分别是 pre-prepare （预准备）阶段，prepare （准备）阶段和 commit （提交）阶段。对于 pre-prepare 阶段，主节点广播 pre-prepare 消息给其它节点即可，因此通信次数为 n-1 ；对于 prepare 阶段，每个节点如果同意请求后，都需要向其它节点再 广播 parepare 消息，所以总的通信次数为 (n-1\*（n-1），即 n^2-n ；对于 commit 阶段，每个节点如果达到 prepared 状态后，都需要向其它节点广播 commit 消息，所以总的通信次数也为 n*（n-1） ，即 n^2-n 。所以总通信次数为 （n-1）+（n^2-n）+（n^2-n） ，即 2n^2-n-1 ，因此pbft算法复杂度为 O（n^2） 。**这里有点疑问应该是(n-1)+(n-1)\*(n-1)+(n-1)\*(n-1)，即为O(n^2)**

2. 两个共识过程对于主节点的选取不同。

   * raft完全无条件服从主节点的命令，不会怀疑主节点作恶的情况。除非主节点挂掉，否则不会重选主节点。
   * pbft从节点可以怀疑主节点命令的正确性，就算主节点的命令是正确的，我也会询问其它从节点看主节点的命令是否正确，只有大部分人(2f+1)的人都认为主节点的命令是正确的时候，从节点才会执行命令。重选主节点有两种情况1. 当主节点作恶。2. 当主节点挂掉。

   

### 参考文献

- https://mp.weixin.qq.com/s/xQVV75uC7MP8V0DlZ0dPUQ
- https://zhuanlan.zhihu.com/p/35847127