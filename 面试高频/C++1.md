### C++ 问题

**1 、请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题。**

 单例模式懒汉和饿汉模式，懒汉模式是在方法中进行进行对象的实力化，饿汉模式是在新建对象时候实例化static对象。

对线程安全问题https://juejin.im/post/5cf09270f265da1bd260d239

https://blog.csdn.net/hb_csu/article/details/80504276

https://juejin.im/post/5e94240cf265da47a74130e0

单例模式：

1. 内部定义该类的静态私有成员变量。
2. 构造方法私有。
3. 提供静态工厂方法，供外部类获取。

线程安全的单例模式有：

1. 懒汉的单例模式线程不安全，可以将getInstance()函数或者代码块添加修饰符synchronized变成线程安全。
2. 饿汉模式。
3. 双重检测单例。volatile指令重排，在未初始化对象的时候就将其Instance指向分配的内存空间。*
4. 枚举单例。*
5. 静态内部类单例。*



饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。

懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。

静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。

枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。

双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)





  **2 、请问你了解哪些设计模式？** 

https://juejin.im/post/5e94240cf265da47a74130e0

**单例模式**

**工厂模式**

它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式

**代理模式**

通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AO的P微实现)

1. 静态代理：简单代理模式，是动态代理的理论基础。常见使用在代理模式

2. jdk动态代理：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。

3. cglib动态代理：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）。CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不能对 final类进行继承。（CGLIB动态代理需要导入jar包）

**策略模式**

定义了一系列的算法 或 逻辑 或 相同意义的操作，并将每一个算法、逻辑、操作封装起来，而且使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛）



  **3 、请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？** 

  **4 、请你说一说 OOP 的设计模式的五项原则** 

**1、单一职责原则**

单一职责有2个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。

**2、接口隔离原则**

表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。

该原则观点如下：
1）一个类对另外一个类的依赖性应当是建立在最小的接口上

2）客户端程序不应该依赖它不需要的接口方法。

**3、开放-封闭原则**

open模块的行为必须是开放的、支持扩展的，而不是僵化的。

closed在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。

核心思想就是对抽象编程，而不对具体编程。

**4、替换原则**

子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。

主要针对继承的设计原则

1）父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的,方法定义或实现。

2）在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。

**5、依赖倒置原则**

上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。

抽象不能依赖于具体，具体应该要依赖于抽象。

  **5 、请你说说工厂模式的优点？** 

- 工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。
- 利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

  **6 、请你说一下观察者模式** 

观察者模式，是一种行为性模型，又叫发布-订阅模式，他定义对象之间一种一对多的依赖关系，使得当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。

观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。

1. 推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。
2. 拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。

**应用场景**

1. 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。
2. 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

  **7 、请你介绍一下单例模式** 

  **8 、单例模式中的懒汉加载，如果并发访问该怎么做** 

加锁，加锁可以锁getInstance函数或者锁住第二个if判断的代码块。

  **9 、装饰器模式和单例模式，使用单例模式应该注意什么？** 

  **10 、说一下 StatiC 关键字的作用** 

生命周期和可见性

  **11 、说一下C++和 C 的区别**

class 面向对象和面向过程。封装，继承，多态。 

  **12 、说一下C++中 Static 关键字的作用** 

修饰符，生命周期和可见性

  **13 、请说一下 static 的作用** 

  **14 、说一说C++中四种 cast 转换** 

https://www.cnblogs.com/Allen-rg/p/6999360.html

1. static_cast<new_type> (expression)

   **静态转换**

   （1）主要用于内置数据类型之间的相互转换；

   （2）用于自定义类时，静态转换会判断转换类型之间的关系，如果转换类型之间没有任何关系，则编译器会报错，不可转换；

   （3）把void类型指针转为目标类型指针（不安全）。

   （4）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证

2. const_cast

   有三个作用：1.常量指针 被强转为 非常量指针，且仍然指向原来的对象；2.常量引用 被强转为 非常量引用，且仍然指向原来的对象；3.常量对象 被强转为 非常量对象。

3. dynmic_cast动态转换

   **（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。**

   **（2）不能用于内置的基本数据类型的强制转换。**

   **（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。**

   **（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。**

   ​     **B中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。**

4. reinterpret_cast()

   reinterpret的英文含义有重新转换的含义。
   就相当于C语言中不相关类型的转换,强转。

   在C++语言中，reinterpret_cast主要有三种强制转换用途：***改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型***。

    **在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！**

  **15 、请说一下 C/C++中指针和引用的区别？** 

指针

  **16 、给定三角形 ABC 和一点 P ( x , y , z ) ，判断点 P 是否在 ABC 内，给出思路并手写代码** 

https://www.nowcoder.com/ta/review-c/review?page=26

  **17 、请你说一下你理解的C++中的 smart pointer 四个智能指针：shared_ptr , unique_ptr , weak_ptr , auto_ptr** 

https://www.cnblogs.com/lanxuezaipiao/p/4132096.html

auto_ptr 指针会出现所有权转移的现象，任何时候只能有一个智能指针指向那块内存区域
unique_ptr 只能有一个主人指针，可以用于STL容器
shared_ptr 可共享的指针
weak_ptr 弱引用类型的指针。**解决shared_ptr因为循环引用资源不能释放的问题**。

weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。不论是否有weak_ptr指向，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。从这个角度看，weak_ptr更像是shared_ptr的一个助手而不是智能指针。
https://blog.csdn.net/Xiejingfa/article/details/50772571

  **18 、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码** 

  **19 、请回答一下数组和指针的区别** 

**数组指针和指针数组**

  **20 、请你回答一下野指针是什么？** 

  **21 、请你介绍一下C++中的智能指针** 

  **22 、请你回答一下智能指针有没有内存泄露的情况** 

https://blog.csdn.net/jcq521045349/article/details/88957222

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

  **23 、请你来说一下智能指针的内存泄漏如何解决** 

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

  **24 、请你理解的C++中的引用和指针** 

都占用一块内存存储指向的地址，但是引用是系统管理，但是指针是用户管理。

  **25 、请你来说一下C++中的智能指针** 

  **26 、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数** 

  **27 、请你来说一下函数指针** 

  **28 、请你来说一下 fork 函数** 

  **29 、请你来说一下C++中析构函数的作用** 

  **30 、请你来说一下静态函数和虚函数的区别** 

  **31 、请你来说一说重载和覆盖** 

  **32 、请你来说一说 Static 关键字** 

  **33 、请你说一说 strcpy 和 strlen** 

  **34 、请你说一说你理解的虚函数和多态** 

  **35 、请你来回答一下++i 和 i++的区别** 

  **36 、请你来说一说++i 和 i++的实现** 

  **37 、请你来写个函数在 main 函数执行前先运行** 

  **38 、有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出 20 个 hello ? for ( int i = 0; i < 20; i++） cout < < " hello " < < endl ;** 

  **39 、请你来说一下智能指针 shared _ ptr 的实现** 

  **40 、以下四行代码的区别是什么？const char *arr = "123" ; char *brr = "123" ; const char crr[]= "123" ; char drr[] = "123 " ;** 

  **41 、请你来说一下 C + ＋里是怎么定义常量的？常量存放在内存的哪个位置？** 





  **42 、请你来回答一下 const 修饰成员函数的目的是什么？** 

  **43 、如果同时定义了两个函数，一个带 const ，一个不带，会有问题吗？** 

  **44 、请你来说一说隐式类型转换** 

  **45 、说说你了解的类型转换** 

  **46 、请你来说一说 C++函数栈空间的最大值** 

  **47 、请你来说一说 extern " C "** 

  **48 、请你回答一下 new / delete 与 malloc / free 的区别是什么** 

  **49 、请你说说你了解的 RTTI** 

  **50 、请你说说虚函数表具体是怎样实现运行时多态的?** 

  **51 、请你说说 C 语言是怎么进行函数调用的？** 

  **52 、请你说说 C 语言参数压栈顺序？** 

  **53 、请你说说 C++如何处理返回值？** 

  **54 、请你回答一下 C++中拷贝赋值函数的形参能否进行值传递？** 

  **55 、请你回答一下 malloc 与 new 区别** 

  **56 、请你说一说 select** 

  **57 、请你说说 fork，wait，exec 函数** 

  **58 、请你回答一下静态函数和虚函数的区别** 

  **59 、请你说一说重载和覆盖** 

  **60 、请你说一说 static 关键字** 

  **61 、请你说一说 strcpy 和 strlen** 

  **62 、请你来说一下 map 和 set 有什么区别，分别又是怎么实现的？** 

  **63 、请你来介绍一下 STL 的 allocaotr** 

  **64 、请你来说一说 STL 迭代器删除元素** 

  **65 、请你说一说 STL 中 map 数据存放形式** 

  **66 、请你讲讲 STL 有什么基本组成** 

  **67 、请你说说 STL 中 map 与 unordered_map** 

  **68 、请你说一说 vector 和 list 的区别，应用，越详细越好** 

  **69 、请你来说一下 STL 中迭代器的作用，有指针为何还要迭代器** 

  **70 、请你说一说 epoll 原理** 

  **71 、请你说一说 STL 迭代器是怎么删除元素的呢** 

  **72 、请你说一说 STL 中 map 数据存放形式** 

  **73 、 n 个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为 O(N)** 

  **74 、请你回答一下 STL 里 resize 和 reserve 的区别** 

  **75 、请你来说一说 STL 迭代器删除元素** 

  **76 、请你说一说 STL 中 MAP 数据存放形式** 

  **77 、请你讲讲 STL 有什么基本组成** 

  **78 、请你说说 STL 中 map 与 unordered_map** 

  **79 、请你说一说 vector 和 list 的区别，应用，越详细越好** 

  **80 、请你来说一下 STL 中迭代器的作用，有指针为何还要迭代器** 

  **81 、请你说一说 epoll 原理** 

  **82 、请你说一说 STL 迭代器是怎么删除元素的呢** 

  **83 、请你说一说 STL 中 MAP 数据存放形式** 

  **84 、 n 个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为 O(N)** 

  **85 、请你回答一下 STL 里 resize 和 reserve 的区别** 

  **86 、请你说一说 STL 里面 set 和 map 怎么实现的** 

  **87、请你来说一下 C++ 中类成员的访问权限** 

  **88 、请你来说一下 C++ 中 struct 和 c } ass 的区别** 

  **89 、请你回答一下 C++ 类内可以定义引用数据成员吗个** 

  **90 、请你回答一下什么是右值引用，跟左值又有什么区别？** 

  **91 、请你来说一下一个 C++ 源文件从文本到可执行文件经历的过程？** 

  **92 、请你来回答一下 include 头文件的顺序以及双引号" "和尖括号＜＞的区别？** 

  **93 、请你回答一下 malloc 的原理，另外 brk 系统调用和 mmap 系统调用的作用分别是什么？** 

  **94 、请你说一说 C++的内存管理是怎样的？** 

  **95 、请你来说一下 C++ / C 的内存分配** 

  **96 、请你回答一下如何判断内存泄漏？** 

  **97 、请你来说一下什么时候会发生段错误** 

  **98 、请你来回答一下什么是 memory leak ，也就是内存泄漏** 

  **99 、请你来回答一下 new 和 malloc 的区别** 

  **100 、请你来说一下共享内存相关 api** 

  **101 、请你来说一下 reactor 模型组成** 

  **102 、请自己设计一下如何采用单线程的方式处理高并发** 

  **103 、请你说一说 C++ STL 的内存优化** 

  **104 、请你说说 select , epoll 的区别，原理，性能，限制都说一说** 

  **105 、请你说说 C++如何处理内存泄漏？** 

  **106 、请问 C++ 11 有哪些新特性？** 

  **107 、请你详细介绍一下 C++ 11 中的可变参数模板、右值引用和 lambda 这几个新特性。** 

  **108 、请你说一下进程与线程的概念，以及为什么要有进程线程，其中有什么区别，他们各自又是怎么同步的** 

  **109 、请你说一说 Linux 虚拟地址空间** 

  **110 、请你说一说操作系统中的程序的内存结构** 

  **111 、请你说一说操作系统中的缺页中断** 

  **112 、请你回答一下 fork 和 vfork 的区别** 

  **113 、请问如何修改文件最大句柄数？** 

  **114 、请你说一说并发（ concurrency ）和并行 ( parallelism )** 

  **115 、请问 MySQL 的端口号是多少，如何修改这个端口号** 

  **116 、请你说一说操作系统中的页表寻址** 

  **117 、请你说一说有了进程，为什么还要有线程？** 

  **118 、请问单核机器上写多线程程序，是否需要考虑加锁，为什么？** 

  **119 、请问线程需要保存哪些上下文， SP 、 PC 、 EAX 这些寄存器是干嘛用的** 

  **120 、请你说一说线程间的同步方式，最好说出具体的系统调用**