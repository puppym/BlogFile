1. 指针对应的地址是不是物理地址 
虚拟地址 
2. 物理地址和虚拟地址通常叫做什么？缩写是什么 

3. 操作系统的寻址方式   

立即数寻址  操作数在指令中    
直接寻址  有效地址在指令中   
寄存器直接寻址  有效地址在寄存器中  
寄存器间接寻址  有效地址在寄存器给出的存储单元中    
寄存器相对寻址 基地址或者变址寄存器+偏移量    
基址加变址寻址 基址加变址   
相对基址加变址 基址+变址+偏移量  
比例变址和基址比例变址和相对基址比例变址这三个寻址方式都是在变址上乘以一个比例因子做换算，最后得出实际地址  

4. linux 中如何计算可用内存 
top 查看  
free 


5. linux 中如何用 top 命令中查看虚地址和实地址的信息
6. 如何用搜索引擎去了解 top 中的虚地址？不用搜索引擎怎么知道  
7. top 的输出中哪些是表明了内存
8. 根据 top 计算可用内存有多少
9. 用 top 看耗性能的线程
10. 还有哪些命令可以找出性能瓶颈  
top  

11. epoll 与 select 比较   
https://www.cnblogs.com/Anker/p/3265058.html  
select 该函数准许进程指示内核等待多个事件中的任何一个发送，并且只在有一个或多个事件发生或经历一段指定的时间后才唤醒 
select，epoll都是IO多路复用的机制
最大并发数：epoll>>select，select默认1024
select返回所有检测fd状态需要轮询fd状态，epoll_wait则只返回活跃连接的fd
select第次需要内核/用户空间内存拷贝，epoll则让内核和用户空间mmap一块内存
[简洁回答](https://www.jianshu.com/p/9fec26dfbc55)

12. epoll 的缺点，如何克服缺点   
epoll适用于有大量空闲的连接的情况，假如网络中只有少数空闲的连接，并且都很活跃难么它的性能会有很大降低  

13. epoll 机制中文件描述符就绪时如何从内核态通知到用户态的进程  
文件描述符变为就绪状态时会调用回调函数，将该文件描述符入一个就绪链表，epoll只需要遍历这个就绪链表就能取出处于就绪状态的文件描述符。 

14. epoll 实现
15. 说说同步 异步的区别
对于系统中存在的临界资源(资源数量少于竞争资源线程数量的资源)例如正在写的数据以后可能被另外一个线程读到，或者正在读的数据可能被另外一个线程写过了，那么这些数据就必须进行同步存取。

异步：当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法返回的时候，就因该使用异步编程，在很多情况下采用异步途径旺旺更加具有效率，同步相当于是阻塞式操作，异步相当于是非阻塞式操作

16. 进程间通信的方式
17. 进程间的通信有哪些机制？在资源内存方面比较如何
18. 同一进程线程间的通信；不同进程线程间的通信；
全局变量   管道，消息队列，共享内存，信号，信号量

19. 如何判断系统在哪些地方耗费性能
20. cpu 调度的单位是什么
线程 

21. 如何让多核 cpu 更好的利用资源
22. 什么是缺页
缺页中断就是要访问的页不存在主存中，需要操作系统将其调入主存中后再进行访问。 

23. 如何控制两个进程对一个数据的访问？怎么处理加锁问题
24. 说一说协程  
协程就是由两个程序商量好，通过某种方式协作运营，共享CPU控制权的方法，一般来说写上的办法是通过关键词yield。
调度算法对于程序来说都是“被动”式的。比如调度算法会把CPU的时间分配给还在IO等待中的程序，虽然可以立即检查并交出CPU，但是这里还是有一个切换的过程。
协程可以说是“主动式”的，由程序来告诉计算机，我要进行等待IO行为了，可以把CPU的控制权交给别人，这个实现的基础是用户态的。

25. 是否了解 netstat  
netstat 命令用于显示各种网络相关的信息，如网络连接，路由表，接口状态  
26. 在 shell 中用 ./a.out | wc- l 结果是多少？管道的输入是哪个进程的 
27. 谈谈 Linux 的文件权限。让只有拥有者才能读写？让拥有者只能读和执行？ 删除文件需要什么权限
28. 假如一个进程在对文件进行读写，管理员把文件删除了怎么办
被程序打开的文件会在/proc/pid/fd/下，删除文件仅删除了文件在磁盘上的inode引用减少了1，/proc/pid/fd/还有该文件的引用，并且可以通过lsof查看到该文件对应的fd后，可以从/proc/pid/fd/找到这个fd恢复该文件内容。

29. 协程与进程线程比较有什么优势  
进线程由操作系统进行调度，协程则由用户程序调度

协程调度开销通常比进线程调度要小
理论上协程能更好的避免无意义的调度来提高性能
但程序必须由开发者承担调度的责任，一般而言协程不具有标准线程使用多CPU的能力

30. 计算机从电源加载开始的启动过程
启动引导程序BIOS，自检，启动引导程序，加载操作系统， 读取配置文件  

31. 什么是中断调用？中断程序的分类  
中断：系统执行期间，系统内发生急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程
硬中断：由硬件引起的中断。如键盘、定时器，以及一些硬件故障等。硬中断又分为可屏蔽中断(如键盘产生的)；非屏蔽中断(如由微处理器产生的)；
软中断：中断指令引起的中断。

32. lsof strace ptrace gdb 使用 
lsof 列出当前系统打开文件(普通文件，目录，管道，socket等)  
strace 跟踪一个进程产生的系统调用  
ptrace 提供一种机制使得父进程可以观察和控制子进程的执行过程，同时提供查询和修改子进程的镜像和寄存器的能力，主要用于执行断点调试和系统调用跟踪。 

33. 内核态和用户态的区别 
34. 为什么需要内核态  
进程处于内核态时，特权级最高，才能使用某些指令。在CPU的有些指令非常危险。所以，设计出用户态进行隔离，而一些必要时候就需要进入内核态执行这些指令

35. 什么时候进入内核态 
进程执行系统调用而陷入内核代码中执行时
用户程序被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态

36. 多线程需要加锁的变量
一些共享的有写操作的变量，一些不可重入函数等。 

37. 程序在内存中的布局  
由高地址到低地址依次是：   
命令行参数，环境变量  
栈（stack）  
可供堆栈增长的空间  
堆（heap）  
未初始化数据段（bss）  
已初始化数据段（data）  
代码段（code）  

38. 死锁 
死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去   
死锁产生的原因：1. 系统资源不足。 2. 进程运行推进顺序不合适。3. 资源分配不当。  
死锁的四个必要条件： 1. 互斥条件：一个资源每次只能被一个进程使用。2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  
破坏上面四个条件中的一个即可避免死锁，

