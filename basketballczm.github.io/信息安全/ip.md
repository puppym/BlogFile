# IP协议 
IP首部的最长为60个字节，首部长度为20个字节，可选字段为40个字节

为什么需要IP分片功能呢？主要是因为硬件环境的MTU限制。一个IP报文最多可以达到65565的最大长度；但是网络硬件限制了帧的大小（以太网限制为1500字节）。

IP fragmentation：在IP层将报文根据MTU分片；每个片段使用与IP报文同样的报头；每个片段独立地路由。

如何进行分片？

IDENT: 也即identifier，用于标识IP报文段的唯一标识符；具有同一IDENT的片段属于同一个IP报文；

FRAGMENT OFFSET: 简称FO，指明当前片段在原始完整的IP报文中的位置（偏移）。该偏移的单位是8个字节。

FLAGS: bit 0：保留；bit 1：不分片；bit 2：更多分片。如果此位是1，那么说明不是最后一个分片，如果是0，说明是最后一个分片。
思考：这个指示位的功能是什么？
因为每个分片的Total Length字段都只会指明当前的分片的长度，而不是完整报文的长度；因此接收方没办法判断报文什么时候结束；有这个指示位，可以帮助判断。

# IP分片攻击 
1. DoS: 思路：攻击者构造两个分片，第一个分片的偏移为0；第二个分片的偏移是64800。因为IP分片可以乱序到达，所以接收方会等待其他分片；同时会为其他分片分配内存空间。相当于一个数据包会使用64K的内存。而且这段空间会持续保留15到255秒。这样，很快会耗尽主机的内存空间，造成DoS。Windows 2000, XP, 以及Unix的各版本都有这个漏洞。 

2. TearDrop攻击：TearDrop攻击的原理，在于构造两个分片。其中，第二个分片完全包含在第一个分片中。也即，第二个分片的FO大于第一个分片的FO，但是第二个分片的FO+ Len，都小于第一个分片最后一个字节的位置，也即第一个分片的FO+len。 1. 首先计算重叠部分长度pre->end-offset。2. 计算第二个部分非重叠部分的起始位置offset = offset + (pre->end-offset)。3. 未重叠的部分 = end->offset，如果这里是泪滴攻击的情况这里会发生溢出，从而未重叠的部分将变成一个非常大的数。 

3. 微小碎片攻击 
Internet协议允许将数据包分段成非常细小的碎片，即使这样做的话，会导致数据和计算开销巨大而变得不切实际。攻击者有时可以利用典型的过滤器行为以及创建特殊片段序列的能力，以便通过过滤器隐藏其他不允许的数据包。在正常的实践中，从不使用这种病态的碎片，因此可以安全地丢弃这些碎片而不会妨碍正常操作。 
通过许多IP实现，可以在传出数据包上形成异常小的片段大小。如果片段大小足够小以迫使某些TCP数据包的TCP头字段进入第二个片段，则指定这些字段的模式的过滤规则将不匹配。如果过滤实现没有强制执行最小片段大小，则可能会通过不允许的数据包，因为它在过滤器中没有得到匹配。

**微小碎片攻击的例子**在此示例中，第一个片段仅包含八个字节的数据（最小片段大小）。在TCP的情况下，这足以包含源和目标端口号，但它将强制TCP标志字段进入第二个片段。
尝试删除连接请求的过滤器（具有SYN=1和ACK=0的TCP数据报）将无法在第一个八位字节中测试这些标志，并且通常会在后续片段中忽略它们。
```c
FRAGMENT 1

      IP HEADER
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+
      |     | ... | Fragment Offset = 0 | ... |     |
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+

      TCP HEADER
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |        Source Port            |       Destination Port        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Sequence Number                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
FRAGMENT 2

      IP HEADER
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+
      |     | ... | Fragment Offset = 1 | ... |     |
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+

      TCP HEADER
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Acknowledgment Number                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data |           |U|A|P|R|S|F|                               |
      | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
      |       |           |G|K|H|T|N|N|                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
```

4. 重叠碎片攻击 

RFC 791（当前的IP协议规范）描述了一种重组算法，该算法导致新的片段覆盖先前接收的片段的任何重叠部分。 
给定这样的重组实现，攻击者可以构造一系列数据包，其中，最低（零偏移）片段将包含无害数据（从而通过管理数据包过滤器传递），并且其中一些后续数据包具有非零offset会重叠TCP头信息（例如目标端口）并导致它被修改。第二个数据包将被通过大多数的过滤器通过，因为它没有零片段偏移量。 
如果接收主机完全符合RFC 791中给出的算法，它将重新组合数据包作为连接请求，因为“坏”数据后面才到达。 
第二个到达的数据包可能会覆盖第一个数据包Sequence Number 之后的内容，那么SYN 和ACK 的值就变成了第二个数据包中的值。

**重叠片段攻击的实例** 
在此示例中，片段足够大以满足上一节中描述的大小要求。过滤器配置为丢弃TCP连接请求数据包。 
第一个片段包含值，例如，SYN = 0，ACK = 1，使其能够无损地通过过滤器。 
具有八个八位字节的片段偏移的第二片段包含与第一片段中给出的TCP标志不同的TCP标志，例如，SYN = 1，ACK = 0。由于该第二个片段不是0偏移片段，因此不会检查它，并且它也将通过过滤器。

```c
FRAGMENT 1

      IP HEADER
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+
      |     | ... | Fragment Offset = 0 | ... |     |
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+

      TCP HEADER
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |        Source Port            |       Destination Port        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Sequence Number                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Acknowledgment Number                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data |           |U|A|P|R|S|F|                               |
      | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
      |       |           |G|K|H|T|N|N|                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   .
                                   .
                                   .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        (Other data)                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


      FRAGMENT 2

      IP HEADER
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+
      |     | ... | Fragment Offset = 1 | ... |     |
      +-+-+-+     +-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+

      TCP HEADER
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Acknowledgment Number                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Data |           |U|A|P|R|S|F|                               |
      | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
      |       |           |G|K|H|T|N|N|                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                   .
                                   .
                                   .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        (Other data)                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
```  

5. 微小碎片攻击和重叠碎片攻击组合 

片段1 : (片段偏移 = 0；长度> = 16）包括整个标头并且完全合法。通常，它描述了一个SYN数据包，它启动新TCP连接到允许接收传入连接的目标主机上的端口。例如，到端口25 的SMTP的传入连接。 

片段2 : (片段偏移 = 0；长度= 8）只有前8个字节，并且具体取决于标头的其他8个字节可能是合法的，但是当与片段1中的相应字节组合之后，会不合法。这样的片段仅包括TCP标头中的端口号和序列号。通常，此数据包使用端口号替换目标端口号，在该端口号上不允许接收传入连接的目标主机。 

片段3 :(片段偏移 > = 2；长度=消息的其余部分）不包含标头并完成消息。 （第三个片段不是攻击的一部分。但是，片段1不能是完整的消息，或者它会在片段2到达之前传递给应用程序，因此需要第三个片段。） 


## 微小碎片攻击防御 
1. 直接法 
设置tmin，它是包含有趣字段所需传输头的最小长度。该长度是从原始未分段IP分组中的传输头部的开头开始测量。 
直接方法涉及计算每个零偏移片段中传输头的长度，并将其与TMIN进行比较。如果传输头长度小于TMIN，则丢弃该片段。不需要检查非零偏移片段，因为如果丢弃零偏移片段，则目标主机将无法完成重组。到目前为止，我们有：

if FO=0 and TRANSPORTLEN < tmin then 
DROP PACKET 

不过，除了TCP之外，其他传输协议的“有趣”字段位于传输头的前八个八位字节中，因此不可能将它们推入非零偏移片段。因此，在撰写本文时，只有TCP数据包容易受到微小碎片攻击，并且不需要对其他传输协议的IP数据包进行测试。因此，微小片段测试的更好版本可能是： 

如果FO = 0且PROTOCOL = TCP，TRANSPORTLEN < tmin 
DROP PACKET

2. 间接方法 
间接方法依赖于这样的观察：当TCP数据包被分段以便迫使零偏移片段（第一个分片）中不存在“有趣”的头部字段时，必定存在FO等于1的片段。 

如果看到具有FO == 1的分组，则相反地，它可以指示在片段集中存在具有八个八位字节的传输报头长度的零偏移片段。丢弃该FO == 1偏移片段将阻止接收主机对数据报文的重组，并且与上述直接方法一样有效。 

## 重叠碎片攻击 
因此，一种通用算法，用于确保过滤器在微小片段攻击和重叠片段攻击面前工作的是： 

如果FO == 1 并且 PROTOCOL == TCP 
DROP PACKET 

如果在路由器中提供基于其他传输协议头中的字段的过滤，则最小值可能更大，具体取决于头中这些字段的位置。特别是，如果允许对传输头的第十六个八位字节以外的数据进行过滤，则由于灵活的用户界面或某些新传输协议的过滤器的实现，丢弃具有FO == 1的数据包可能是不够的。

## 微小碎片攻击和重叠碎片攻击组合  
虽然看起来非常优雅，但RFC 1858的间接方法并不健全。除了阻止FO = 1分组之外，还必须阻止保持少于完整报头的FO == 0。 

如果FO == 0且PROTOCOL == TCP，则TRANSPORTLEN < tmin 
DROP PACKET 

如果FO == 1，且PROTOCOL == TCP，则 
DROP PACKET 
