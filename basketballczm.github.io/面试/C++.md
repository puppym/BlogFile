## C++后台开发
1. static 关键字有哪些用法：
生命周期和可见性

2. 说说继承和组合的概念？什么时候应该用继承？什么时候应该用组合？
Is-A关系应该用继承关系(person,student,teacher)继承关系父类的实现对子类是可见的，容易破坏封装性，把父类的实现细节暴露给子类，相当于白盒复用。has-A关系是组合关系(如眼，鼻子，口，耳都是头的一部分所以应该使用组合)，被包含类的生命周期受包含类控制，被包含类会随着包含类创建而创建，消亡而消亡。组合属于黑盒复用，被包含对象的内部细节对外是不可见的，封装性比较好，实现上相互依赖比较小。GoF在设计模式中指出的一大原则是：优先使用对象组合，而不是类继承。

3. C++ 的菱形继承会发生什么问题？画出对应的内存布局
会出现二义性，即对于base的调用要使用作用域的情况来说明。可以通过虚拟继承virtual public 来消除二义性，但是虚拟继承的开销是增加虚函数指针。https://blog.csdn.net/SuLiJuan66/article/details/48897867

4. 说说对 C++ 智能指针的了解
智能指针一共有auto_ptr, unique_ptr和shared_ptr背后的设计思想如下：将基本类型指针封装为类对象指针，(这个类肯定使模板，以适应不同基本类型的需求)，并在析构函数中别写delete语句删除指针指向的内存空间。
为何要抛弃auto_ptr：因为它转换所有权是隐式的，使用转换所有权的指针会造成程序崩溃。
unique_ptr为何优于auto_ptr：因为unique_ptr在转换所有权的过程中会在编译时刻就报错，避免运行时刻报错。总之，当程序试图将一个unique_ptr赋值给另一个时，如果源unique_ptr是个临时右值，编译器允许这么做，如果源unique_ptr将存在一段时间，编译器禁止这样做。
shared_ptr(boost也提供)在转换所有权的过程中也能够正常的运行，因为shared_ptr采用引用计数，两个shared_ptr都指向同一块内存，在释放空间时因为要事先判断引用计数值的大小而不会出现多次删除同一个对象的情况。

注意的问题：智能指针都没定义赋值运算符的时候执行深复制，因为这样的缺点使浪费空间； 建立所有权的概念，对于特定的对象，只有一个智能指针可以拥有。这就是auto_ptr和unique_ptr的策略，但是unique_ptr的策略更为严格；创建智能更高的指针，跟踪引用特定对象的智能计数，当计数减为0时才调用delete，这是share_ptr的设计思路。

智能指针的选择：
如果程序要使用多个指向同一对象的指针，应该选择shared_ptr。STL的算法支持复制和赋值操作，这些操作可以用于shared_ptr。但不能用于另外两个。
如果程序不需要多个指向同一对象的指针，则使用unique_ptr，如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是个不错的选择。
在unique_ptr为右值时可以将其赋值给shared_ptr，这与将一个unique_ptr赋给一个需要满足的条件相同。

5. 说说虚函数实现机制
每个实例化的对象都会存在一个虚指针，该虚指针指向一个虚表。所有虚函数的地址都存在于这个虚表中。

6. 如果父类中仅有方法，子类有一个 int 变量，这时候 sizeof 是多大
4

7. 指针一定是 4 个字节吗
不一定，在64位windows下面是4个字节，但是在64位linux下面是8个字节。

8. define 和 inline 函数的区别是什么
define:定义预编译时的处理宏，只进行简单的字符替换，无需类型检查，typedef 定义类型别名，用于复杂的类型。inline：内联函数对编译器提出建议，是否进行替换，编译器有权拒绝。是在编译阶段进行展开的。

9. const static 在哪里初始化
类的static成员变量要在类外使用类作用域进行初始化，并且不加static，const static在类外进行赋值初始化，const成员函数要在构造函数参数列表初始化。

10. 派生类的构造函数和析构函数执行顺序
派先执行基类构造，再执行派生类构造，先执行派生类析构，再执行基类的析构。

11. 什么情况下基类的析构函数没有被调用
在执行派生类析构时出现异常，造成内存泄漏，这里引入智能指针的概念。

12. 如何生成静态库？如何生成动态库
首先在生成库的cpp中将要导出的函数加关键字extern，
动态库： gcc -fPIC -shared xxx.c -o libxxx.so    gcc -fPIC -shared xxx.o -o libxxx.so  
静态库： ar -rc libxxx.a xxx.o  ar -rc libxxx.a xxx1.o xxx2.o xxx3.o (不能使用XXX.c)

13. 如何用 gdb 调试
首先编译时使用-g生成带调试信息的可执行文件，然后再gdb 可执行文件，打断点，运行到断点处。

14. coredump 查看，core 文件分析
core dump又叫核心转移，当程序运行过程中发生异常，程序异常退出，有操作系统会把程序当前的内存状况存储在一个core文件中，然后通过bt来查看堆栈。valgrind是一款专门用作内存调试，内存泄漏检测的开源工具软件。
造成segment fault 产生core dump的可能原因：内存访问越界，多线程使用线程不安全的函数，多线程读写未加锁保护，非法指针堆栈溢出
ulimie -c unlimited 打开dump core功能 ulimit -c 或 ulimit -a可以查看core file的代销的配置情况。gdb ./test test.core进入gdb core调试模式。

15. 如何调试运行中的程序
日志，我写的辅助工具

16. 运行了几天的程序崩掉，如何分析错误
日志

17. 如何编写 makefile
```c
    cc = gcc
    prom = calc
    deps = $(shell find ./ -name "*.h")
    src = $(shell find ./ -name "*.c")
    obj = $(src:%.c=%.o) 
    
    $(prom): $(obj)
        $(cc) -o $(prom) $(obj)

    %.o: %.c $(deps)
        $(cc) -c $< -o $@

    clean:
        rm -rf $(obj) $(prom)
```
makefile先将一些重复的地方指定为一些宏，然后编译生成.o，在这一步需要指定一些头文件；将生成的所有.o链接生成可执行文件，这一步需要链接一些系统的库函数。

18. 编译器的编译过程？链接的时候做了什么事？在中间层优化时怎么做?
词法，语法，语义，中间代码的生成，中间代码的优化，目标代码的生成，目标代码的优化，链接生成可执行文件。
静态链接和动态链接。
局部优化
基本块的划分
基本块的变换
基本块的DAG表示
DAG的应用
构造算法讨论
控制流分析和循环优化
程序流图与循环


19. STL 各容器如何实现
https://blog.csdn.net/single_wolf_wolf/article/details/52854015
vector 使用3个指针，myfirst，mylast, myend。大小size = mylast-myfirst; 容量capacity = myend-myfirst;容器是乘2扩充。扩容后先重新分配一块更大的内存，然后将原元素拷贝到新内存中，并销毁原来的内存。
https://blog.csdn.net/u012658346/article/details/50725933
vector 是使用数组实现，支持快速随机访问
list   双向链表
dequeue是一个中央控制器和多个缓冲区
stack  list和deque，封闭头部，不用vector是因为容量大小受到限制
queue  list和deque，封闭头部，不用vector是因为容量大小受到限制
set    红黑树，有序，不重复
map    红黑树，有序，不重复
hash_map(标准unordered_map) hash表，无序，不重复
map 底层是用红黑树存储，查找时间复杂度使logn级别
hash_map底层使用hash表存储，查询时间复杂度是常数级别。
什么时候使用map，什么时候使用hash_map这个要看具体的应用，不一定常数级别的hash_map就一定比logn级别的map要好，hash_map的hash函数以及解决地址冲突都需要耗时，并且hash表是以空间效率来换取时间效率的，因而hash_map的内存消耗肯定要大，一般情况下，如果记录数非常大，考虑hash_map，查询效率会高很多，如果考虑内存消耗，要谨慎使用hash_map。
解决hash冲突：开放定址法，再hash法连续hash直到不惨胜冲突为止，链地址法，建立公共溢出区：将hash表分为基本表和溢出表，凡是和基本表发生冲突的元素一律填入溢出表。

20. 适配器是用来做什么的
在适配器模式中引入了一个被称为适配器的包装类，而它所包装的对象称为适配者。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用，适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标类接口。适配器模式分为对象适配器模式和类适配器模式。
http://blog.jobbole.com/109381/

21. queue 如何实现
底层使用list实现

22. map 用什么实现
红黑树，有序，不重复

23. 如何实现 vector？优化 O（n） 的复制
vector 性能分析： https://www.oschina.net/translate/6-tips-supercharge-cpp-11-vector-performance?print
1. 分别一个新的内存块，其容量是容器当前容量的数倍。多数实现中，vector 和 string 容量的提升因子在 1.5 和 2 之间。
2. 从容器原来占用的内存中将元素拷贝到新分配的内存中。
3. 释放原有内存中的对象。
4. 释放原有内存。

24. 红黑树插入数据发现不平衡应该怎么做
首先介绍二叉查找树，二叉查找树的中序遍历是一个升序的序列，为了解决二叉查找树多次插入新节点导致不平衡的特点引入平衡二叉树(二叉查找树)。红黑树是一种平衡二叉树。
红黑树的性质：
1. 节点是红色或者黑色
2. 根节点是黑色
3. 每个叶节点都是黑色或者空节点(NIL节点)
4. 每个红色节点的两个子节点都是黑色(从每个叶节点到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
正是因为这些规则的限制，才保证了红黑树的自平衡，红黑树从根到叶子的最长路径不会超过最短路径的2倍。
当插入和删除节点时候，红黑树的规则可能被打破，因此需要作出一些调整来维持规则。调整分为变色和旋转，旋转分为左旋转和右旋转
左旋转：逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。
右旋转：顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。
map和set的底层都是使用红黑树



25. debug 模式和 release 模式编译的区别
生成的可执行文件大小有区别， debug模式包含了调试信息，release模式是发布模式，不包含调试信息。

26. 如何查看链接的动态库
file .so用来查看文件类型。 ldd .so用来查看动态链接库本身需要包含的动态库文件。
