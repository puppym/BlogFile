### 椭圆曲线的数学表示

首先椭圆曲线的数学表达为`y^2 = x^3 + ax + b, 其中4a^3 + 27b^2 ≠ 0`，所以我们只需要通过a, b两个参数就可以确定一条曲线的形状。在此之外还需要四个属性来确定椭圆曲线在密码学的子群形态。

p - prime定义有限域的大小

G - base point / generator 所选取的G点

n - order 子群的阶

h - 子群的辅助因子

### 群组和群组中的运算

群是一个集合，表示集合G，定义一个加法群(G,+)，满足加法群的限制条件满足以下条件：

1. 群运算满足结合率`a+b+c = (a+b)+c = a+(b+c)`。
2. 存在唯一元素0属于G满足，a+0 = 0+a，则称该元素为单位元素
3. 对于任意元素a，存在唯一元素-a属于G，并且`a+-a = -a+a = 1`，则-a称为a的逆元。

另外还有元素a,b都属于G，并且`a+b = b+a`，如果满足这个条件就是交换群，也就是阿贝尔群。

乘法群的概念类似上面

在椭圆曲线上我们将加法群和曲线对应为：

1. 我们将曲线上的点对应到群上的元素。
2. 单位元素定义为曲线上无穷大处的点。
3. 点P的逆元对应位x轴的对称点

加法的定义P，Q，R，3点在一条直线上，使得P+Q+R=0，所以P+Q= -R在图像上表示为R关于x的对称点。

### 有限域和有限域中的运算

有限域几位有限有限元素的集合，模为P的整数域，p是个素数，记为Z/p,GF(p),F(P)，所以F(p)中的元素集合0~p-1，采用模运算。

举例，在F(23)中：

- 加法 `18 + 9 mod 23 = 4`
- 减法 `7 - 14 mod 23 = 16`
- 乘法 `4 * 7 mod 23 = 5`
- 加法逆  `-5 mod 23 = 18`
- 乘法逆 `9^-1 mod 23 = 18`

关键注意的是 p一定是一个素数：假设是偶数4, 则2没有乘法逆元 2 * x mod 4 = 1? 无解。

 

着重讲一下**有限域中的除法**，就是**求一个元素逆元**的方法，采用的是**扩展欧几里得算法**（extended Euclidean algorithm）。

### 子群以及子群的阶和基点

**循环子群（cyclic subgroups）**，选择一个基点G，然后关于G的所有经过标量乘法后得到的元素所组成的集合，叫做循环子群。后面的子群都用循环子群的概念。



当满足 nP = 0时, n的最小值就是该子群的阶，简单来说，因为是循环的，所以有无数个n，能满足 nP = 0，但是存在一个最小的n, 该值就是子群的阶。这儿还有个概念就是说子群的阶，是群阶的整除数(divisor), 这边有数学证明： Lagrange's theorem.我们就不做过多介绍。



基于这个理论，我们可以求n:

- 先算出该有限域群的阶N（schoof's algorithm ）
- 寻找N的所有可整除数(divisor)
- 将N的每一个除数均带入计算 nP = 0
- 最小的n就是P子群的阶。

当N是个合数，它有很多整除数，但是如果是一个素数，将只有1和本身。



**如何寻找一个基点?**



在ECC算法中，我们希望子群的阶足够大, 所以我们计算一条曲线的N，找到N的一个足够大的子群阶, 然后寻找到一个合适的基点。所以我们不是寻找基点，再计算阶, 而是寻找阶, 再计算基点。关键点就是确定h，h = N/n，因为n能被N整除，所以h是一个整数，**h有一个名字叫做 cofactor of the subgroup。**



具体的流程如下：

- 计算曲线的阶N
- 选择一个阶为n的子群，n必须是一个素数
- 计算 h = N/n
- 随机选择椭圆上的一个P点
- 计算 G = hP

- 如果G是0，重新选择P点

这样我们就找到了子群的生成点(generator) G，以及子群阶(order) n, 以及子群的辅助因子(cofactor) h.



### 定义一条椭圆曲线

所以我们再回到刚开始的介绍，定义一条可用的椭圆曲线，需要给定一些参数：

- prime p, 定义有限域的大小（相当于上面的N值，首先要计算有限域群的阶N）
- coefficients a b, 椭圆曲线的a, b系数
- base port G, 基点G
- order n，子群的阶
- cofactor h, 子群的辅助因子



确定一条椭圆曲线具体需要哪些参数分析：

- 参数a, b 确定一条椭圆曲线的形状
- 一个质数P用于描述有限域的大小
- 一个用于生成循环子群的基点G
- 子群（循环子群）的阶数n
- 子群的协因子 ![[公式]](https://www.zhihu.com/equation?tex=h) （ ![[公式]](https://www.zhihu.com/equation?tex=h%3DN%2Fn) ，其中 ![[公式]](https://www.zhihu.com/equation?tex=N) 是椭圆曲线群的阶数）

这六个参数 ![[公式]](https://www.zhihu.com/equation?tex=%28p%2Ca%2Cb%2CG%2Cn%2Ch%29) 联合起来定义了一种ECC算法所用到的椭圆曲线。

在代码上主要抓住两个部分：

1. 椭圆曲线群组中的点的运算。（加法和乘法）
2. 椭圆曲线有限域中横纵坐标的加减乘除运算。（除法采用扩展殴几里德算法）
3. 然后就是按照文档的步骤实现即可。



 参数是个六元组(p, a, b, G, n, h)

当这些参数确定之后，就可以进行后续的DH，DSA等的计算了。



### ECDH和ECDSA

在看代码之前，我们先确定一个算法，叫做**公私钥生成算法**，采用的是**x \* G = P 的难以逆向推导的特性，产生私钥 x，和公钥 P**，有了这两个概念，我们看算法：

**注意下面的运算都是有限域上的群运算**

很简单的DH算法：

Alice (d1, H1), Bob(d2, H2)

Alice 计算 `S = d1*H2`, Bob计算 `S=d2*H1`, 两个S将是相同的。

然后取S点的x座标就可以当作双向加密的密钥，TLS中，用x座标与其他点连接起来做密钥

ECDHE, 在TLS中，每次通信将随机产生新的公私钥用于交换新的加密密钥，保障前向安全。

 



**加密和签名算法下面描述比较模糊，具体可以参考该链接 [link](https://blog.csdn.net/weixin_42117918/article/details/86421877)**

再看 DSA签名和验证算法：

**签名**

\- Alice 将用自己的私钥k, 签名一条消息，然后 Bob将用Alice的公钥K进行验证

\- 签名的消息是被Hash过的字符串，Hash过后为了保障和n的bit位数一致，将对字符串进行截取。



具体的流程如下：



- 选取 1 ~ n-1中的随机数 r
- 计算 P = rG(x, y)
- 计算 r = P的x坐标 mod n
- 如果 r = 0, 则重新选择k
- 根据随机数r，消息M的哈希h，私钥k，计算`s = r^-1 * (h + kx) mod n` ，简化以下`s = (h + kx)/r`。
- 如果 s = 0, 则重新选择r
- 将消息M和签名{rG, s}发送给接收方

（rG, s)即是signature.

这边 r^-1是 r的逆元，所以要求n是一个素数，这就是为什么我们的椭圆曲线的阶都是素数的原因，否则无法使用ECDSA



**验证**

具体的流程如下：

* 接受方收到消息M，以及签名{rG, s}
* 根据消息求哈希h
* 使用发送方的公钥K计算：`(s^-1*h mod n)*G + (s^-1*x mod n)*K` 简化一下也就是`hG/s + xK/s`

验证原理，原理如下： 

　　hG/s + xK/s = hG/s + x(kG)/s = (h+xk)G/s 
　　= r(h+xk)G / (h+kx) = rG



我们在做签名的时候，要保证r的足够随机性，这样保障每一个签名都不一样，如果r一直使用的是同一个，将有办法获取原始的私钥 k。

对于消息M1 和 M2 的签名(r1, s1) 和 （r2, s2）

首先因为随机数r相同，则r1 == r2，因为r为公钥的x坐标。

由于`s = (h + kx)/r`

`r = (s2-s1)^-1*(h2-h1)`  1

`k = x^-1 * (sr - h)`  2

将1带入2中

`k = x^-1 *  (s*(s2-s1)^-1*(h2-h1) - h)`

因此可以求出最后的私钥k。

### 参考文档

[sun椭圆曲线的数学表示](https://mp.weixin.qq.com/s?__biz=MzAwMjEzNzAzNQ==&mid=2650719438&idx=2&sn=63e085dbf2f4c573661185f99bdb486c&chksm=82c56a6ab5b2e37cc55bbff7b8513c228ceddcd4c14524d78d410bb0e7929385f9738b648936&scene=21#wechat_redirect)

