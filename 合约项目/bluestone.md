## blueStone contract 分析

### DepositManager

```c++
    struct State {
        /// Includes enabled and disabled desposit terms.
        /// We need to keep disabled deposit terms for deposit maturity update.
        // 所有存储周期的list
        uint256[] allDepositTermList;
        // 已经开启的存储周期list，因为打开的存储周期到期后需要被关闭
        // **注意这里的存储周期是每一种token都会包含的存储周期**
        uint256[] enabledDepositTermList;
        // Deposit term -> has been enabled once?
        // 记录存储周期以前是否被打开
        mapping(uint256 => bool) isDepositTermInitialized;
        // Deposit term -> enabled?
        // 查看当前存储周期是否打开
        mapping(uint256 => bool) isDepositTermEnabled;
        
        
        /// Include enabled and disabled deposit tokens.
        /// We need to keep disabled deposit tokens for deposit maturity update.
        // 所有存储token address的list
        address[] allDepositTokenAddressList;
        // 当前开启的存储token的list，因为一些打开的存储周期token到期后需要被关闭
        address[] enabledDepositTokenAddressList;
        // Token address -> DepositToken
        // token的地址和token相关信息的映射
        mapping(address => DepositToken) depositTokenByAddress;
        // ID -> DepositRecord
        // 对于每一笔存款标明一个bytes32的存款ID，deposit ID 为当前一些存款数据的hash。bytes32 currDepositId = keccak256(abi.encode(accountAddress, poolId, self.numDeposits));
        mapping(bytes32 => DepositRecord) depositRecordById;
        // When was the last time deposit maturity updated
        // 上一次存款周期到期的时间戳，主要是用于更新存款周期到期
        uint256 lastDepositMaturityUpdatedAt;
        // 存款数量
        uint256 numDeposits;
        // AccountAddress -> DepositIds
        // 账户地址对应存款ID数组，
        mapping(address => bytes32[]) depositIdsByAccountAddress;
    }
```



```c++
// Hold relavent information about a deposit token
    struct DepositToken {
        // Only enabled token can perform deposit-related transactions
        // 仅仅isEnabled的token address能够进行存款操作
        bool isEnabled;
        // total deposit weight history
        // token address 总共的历史利率权重，主要是和用户通过自身权重和总权重来进行利率分配。
        DepositInterestHistory depositInterestHistory;
    }


    // Record interest index on a daily basis
    // 通过map来记录每日所产生的利息权重，这样可以计算总的权重值
    struct DepositInterestHistory {
        /// Each interest index corresponds to a snapshot of a particular pool state
        /// before updating deposit maturity of a PoolGroup.
        ///
        /// depositInterest = loanInterest * depositWeight / totalDepositWeight * (1 - protocolReserveRatio)
        /// depositWeight refers to weight in deposit record

        // days number -> total deposit weight
        // 天数和当天和以前存款的总权重  相当于给每天的存款总权重添加了快照
        mapping(uint256 => uint256) totalDepositWeightByDay;
        // days number -> total deposit interests
        // 快照存款阶段每天的存款利率
        mapping(uint256 => uint256) totalInterestByDay;
        // 上一天的标识，已经过去的天数
        uint256 lastDay;
    }
```

```c++
// 一个Account address对应多个存款ID，每个存款ID对应一个DepositRecord，该记录就是用来记录每次存款的信息    
struct DepositRecord {
        bytes32 depositId;
        address ownerAddress;
        address tokenAddress;
        uint256 depositTerm;
        uint256 depositAmount;
        uint256 poolId;
        uint256 createdAt;
        uint256 maturedAt;
        uint256 withdrewAt;
        uint256 weight;
        address distributorAddress;
        uint256 depositDistributorFeeRatio;
    }
```



```c++
    // 下面两个结构体为上面结构体在代码中组合形成的信息
    // 每一个Account address可能存在多笔存款 address => bytes32[] ，获取每笔存款的DepositRecord中的一些信息形成List
	struct DepositRecordListView {
        bytes32[] depositIdList;
        address[] tokenAddressList;
        uint256[] depositTermList;
        uint256[] depositAmountList;
        uint256[] createdAtList;
        uint256[] maturedAtList;
        uint256[] withdrewAtList;
    }

// deposit 操作的参数信息，对于deposit的一个参数
    struct DepositParameters {
        address tokenAddress;
        uint256 depositAmount;
        uint256 depositTerm;
        address distributorAddress;
        uint256 depositDistributorFeeRatio;
    }
```



### LiquidityPools

```c++
    // 一种token address对应一个池组，一个组对应多个pool
	struct State {
        // token -> PoolGroup
        mapping(address => PoolGroup) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;
        uint256 numPools;
        uint256 firstPoolId;
        // pool id -> Pool
        mapping(uint256 => Pool) poolsById;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount borrowed from this pool
        uint256 borrowedAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
        // Total deposit weight
        uint256 totalDepositWeight;
    }
```



### LoanManager

```c++
    struct State {
        TokenStorage loanTokens;
        TokenStorage collateralTokens;
        // ID -> LoanRecord
        // 下面两个map address => bytes32[] =>LoadRecord 对应每个地址的借款记录
        mapping(bytes32 => LoanRecord) loanRecordById;
        // accountAddress -> loanIds
        mapping(address => bytes32[]) loanIdsByAccount;
        // account -> tokenAddress -> availableCollateralamount
        // 账户可以获得的抵押数量
        mapping(address => mapping(address => uint256)) availableCollateralsByAccount;
        /// loan token -> collateral token -> enabled
        /// An loan token pair refers to loan token A using collateral B, i.e., "B -> A",
        /// Loan-related transactions can happen only if "B -> A" is enabled.
        // 贷款和抵押相互关联的数据是否打开
        mapping(address => mapping(address => bool)) isLoanTokenPairEnabled;
        /// loan token -> collateral token -> minimum collateral coverage ratios
        /// For example, if minCollateralCoverageRatios[DAI][ETH] = 1.5 when 1 ETH = 150 DAI, it means you
        /// can loan 100 DAI at most for colleteralize 1 ETH. And when the collateral coverage ratio of loan
        /// is below 1.5, the colleratal will be liquidated
        mapping(address => mapping(address => uint256)) minCollateralCoverageRatios;
        /// loan token -> collateral token -> liquidation discounts
        // 贷款token => 抵押token => 折扣率
        mapping(address => mapping(address => uint256)) liquidationDiscounts;
        uint256 numLoans;
    }

    struct TokenStorage {
        /// When referenceCounter < 0, the token was enabled as a loan token pair list before,
        /// but has been disabled and not existed in loan token pair list now.
        /// If referenceCounter == 0, the token never existed in loan token pair list.
        /// If referenceCounter > 0, the token exists in `referenceCounter` loan token pair list.
        /// 统计token贷款组件的数量，为负数则为以前出现过的次数，如果为正数为当前出现的次数，并且当为负数的时候也就是该token为未激活状态
        mapping(address => int256) referenceCounter;
        /// an array store all token that have ever existed in loan token pair list.
        address[] tokenList;
    }
```

```C++
    // 借贷记录
	struct LoanRecord {
        bool isValid;
        bytes32 loanId;
        address ownerAddress;
        address loanTokenAddress;
        address collateralTokenAddress;
        uint256 loanAmount;
        uint256 collateralAmount;
        uint256 loanTerm;
        uint256 annualInterestRate;
        uint256 interest;
        uint256 minCollateralCoverageRatio;
        uint256 liquidationDiscount;
        uint256 alreadyPaidAmount;
        uint256 liquidatedAmount;
        uint256 soldCollateralAmount;
        uint256 createdAt;
        uint256 lastInterestUpdatedAt;
        uint256 lastRepaidAt;
        uint256 lastLiquidatedAt;
        bool isClosed;
        // pool id -> loan amount
        /// How much have one borrowed from a pool
        mapping(uint256 => uint256) loanAmountByPool;
        address distributorAddress;
        uint256 loanDistributorFeeRatio;
    }
	
	// 记录查询视图
	struct LoanRecordListView {
        bytes32[] loanIdList;
        address[] loanTokenAddressList;
        address[] collateralTokenAddressList;
        uint256[] loanTermList;
        uint256[] remainingDebtList;
        uint256[] createdAtList;
        uint256[] currentCollateralRatioList;
        bool[] isClosedList;
    }

	// 贷款动作传入的参数
    struct LoanParameters {
        address loanTokenAddress;
        address collateralTokenAddress;
        uint256 loanAmount;
        uint256 collateralAmount;
        uint256 loanTerm;
        bool useAvailableCollateral;
        address distributorAddress;
        uint256 loanDistributorFeeRatio;
    }
```



### liquidityPools

```c++
    struct State {
        // token -> PoolGroup
        mapping(address => PoolGroup) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;
        // pool在该poolGroup中的数量
        uint256 numPools;
        // 记录该组的第一个poolID
        uint256 firstPoolId;
        // pool id -> Pool
        // 注意这里的pool ID和pool Index
        // pool ID = pool Index + firstPoolID
        // pool Index 和 loanTerm等价
        mapping(uint256 => Pool) poolsById;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount borrowed from this pool
        uint256 borrowedAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
        // Total deposit weight
        // 主要是用来进行利息的分配，这里的值是利息的总额
        uint256 totalDepositWeight;
    }
```





### 存款贷款模型总结

1. 每一种`tokenAddress`和term对应一个`poolGroup`，`poolGroup`的`term（numpools）`只能通过`setMaxLoanTerm`接口改变。`enableterm`是打开`term（numpools）`以下的term，标识该周期可以被存储，但是借贷的时候只是校验了`loanParameters.loanTerm <= localVars.maxLoanTerm`，并没有校验term是否enable。
2. 每一种`tokenAddress`和term组成一个`poolGroup`。`poolGroup`的poolnum表示每个周期池子里面的数量。每一个池子对应相应的借款和存款记录以及总共的





### 问题校验

1. `LoanManager`中重复了代码`using SafeERC20 for ERC20;`。
2. `deposit`值为0的情况是否值得考虑，为0的情况和存储值非常小的情况相似，需要选择最小存储值，但是最小存储值的如果是不同币种，那么其最小存储价值也就不相同，如何确定最小存储价值。
3. `enableDepositTerm`和`enableDepositToken`中初始化`poolGroup`代码逻辑有问题

对于`enableDepositToken`函数中的下面代码：

```solidity
// Initialize pool groups if they haven't been initialized
for (uint256 i = 0; i < self.enabledDepositTermList.length; i++) {
    uint256 depositTerm = self.enabledDepositTermList[i];
    liquidityPools.initPoolGroupIfNeeded(tokenAddress, depositTerm);
}
```

`initPoolGroupIfNeeded()`函数只会被`tokenAddress`对应的`enabledDepositTermList[0]`初始化一次，后面`enabledDepositTermList`的值都不会被初始化。


对于`enableDepositTerm`函数中的代码：

```solidity
// Initialize pool group for each existing token if they haven't been initialized
for (
    uint256 i = 0;
    i < self.enabledDepositTokenAddressList.length;
    i++
) {
    address tokenAddress = self.enabledDepositTokenAddressList[i];
    liquidityPools.initPoolGroupIfNeeded(tokenAddress, term);
}
```

由于`tokenAddress`对应的`poolGroup`已经被初始化，上面`initPoolGroupIfNeeded`函数不会初始化任何`poolGroup`。即`enableDepositTerm`不能改变`tokenAddress`的`depositTerm`，代码冗余。

4. 在`deposit`函数中

```solidity
require(
            self.isDepositTermEnabled[depositParameters.depositTerm],
            'DepositManager: invalid deposit term'
        );
```

中由于`tokenAddress`的term不一定是最大值，因此在初始化`tokenAddress`和`enabledDepositTermList[0]`对应的`poolGroup`之后，再次`enableDepositTerm`，再执行`deposit`会存储成功，也就是比当前的`poolGroup`获得更大的存储周期，这样做是不合理的。

5. `LiquidityPools`中的`localVars`结构体未使用。