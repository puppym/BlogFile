总的提纲

•1. 区块链概述

•2. 以太坊概述

•3. 当前研究现状

•4. 存在问题

•5. 解决方案

•6. 展望



1. 什么是区块链。
2. 区块链解决了什么问题。
3. 相比传统的场景在什么场景下使用区块链
4. 什么是以太坊
5. 以太坊和比特币相比有什么区别
6. 为什么以太坊上的数据抽取和分析相比比特币上的数据分析有价值
7. 当前在以太坊上数据分析的现状，研究方法
8. 上述的研究方法存在什么问题 2点
9. 我的解决方法是什么
10. 解决方案的难点在哪里
11. 目前工作
12. 期望以后工作的结果
13. 工作时间表
14. 谢谢







### 技术概述

**技术路线：**

**Geth介绍**

Geth是go-ethereum项目的客户端，也是目前使用最广泛的客户端，支持windows，linux，MacOS3种操作系统。Geth的主要功能有同步区块，查询区块和交易信息，账户管理，挖矿，执行交易等功能，以太坊Geth整体架构图如图：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

按照上面以太坊整体架构图，可以具体分析一个全节点启动的全部过程，过程如下：

\1.  首先通过go-ethereum中的cmd/geth/main.go初始化CLI客户端命令行解析工具，并且将解析结果保存到相关配置中，然后启动geth服务，geth是整个节点系统的入口，它会根据输入的命令行参数创建一个节点去启动各种服务，并且在启动和运行各种服务过程中呈现阻塞模式。

\2.  Geth服务首先通过makeFullNode函数来通过依次加载各个服务的配置来创建一个全节点，然后依次注册Eth服务，shh服务，GraphQL服务，EthStates服务。

\3.  Geth服务通过startNode函数依次启动上面的服务，全节点开始同步区块到内存，并且遍历每个区块中的交易进行计算和验证，计算完成并且验证通过后的将区块数据，交易数据和票据数据分别存入levelDB,并且更新当前的世界状态。

每个区块通过P2P传输首先传输到全节点内存，然后通过计算和验证每个区块中的交易来进行世界状态的变更。对于每个区块其状态变更如下所示：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

 

对于区块中的每个交易，可以由交易所触发的功能和数据值的不同分为2种：创建合约交易和消息调用交易。对于创建合约交易而言，其交易中携带合约的字节码，交易的接收者就是交易的随机数和交易数据的Hash随机创建的合约地址，该种交易执行过程中会将合约的字节码存储到合约账户状态的code域中。交易的执行具有原子性，如果一笔交易再执行过程中发生异常，那么交易已经执行部分的更改不会合并到世界状态中，但是交易执行已经消耗的gas费用不会返还。对于一个区块而言，每笔交易执行的中间状态不会被保存，创建合约交易状态变化具体过程如下图所示：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)

对于消息调用交易而言主要是改变调用合约的某一功能函数，通过合约函数来改变合约的存储状态，也就是合约账户状态中的storage域。消息调用交易状态变化具体过程如下所示：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image008.gif)

 

对于某个交易而言，其具体状态转换过程可定义如下：

\1.  检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误。

\2.  计算交易费用fee=STARTGS * GAPPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数nonce。如果账户余额不足，返回错误。 

\3.  设定初值GAS = STARTAGS， 并且根据交易的字节数减去一定的gas费用。

\4.  从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者gas用完。

\5.  如果因为发送者账户没有足够的钱或者代码执行耗尽瓦斯导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。

\6.  交易执行成功，将所有剩余的gas归还给发送者，消耗掉的gas作为交易费用发送给矿工。

**![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)**

**EVM分析**

EVM是以太坊协议的一部分，它用来处理智能合约的部署和执行，除了在外部账户之间的简单转账交易之外，其他所有涉及状态更新的操作都是通过EVM来计算的。从高层抽象的角度看，运行在以太坊区块链上的EVM可以被想象成一个包含数百万执行对象的全球化的去中心化计算机，这些执行对象都拥有他们各自的永久数据存储。

EVM是一个基于栈的架构，在一个栈中保存了所有内存数值。EVM的数据处理单位被定义为256位的字，主要是为了在EVM中执行与哈希运算和椭圆曲线相关操作，

 

EVM的架构如下图所示：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif)

当一个交易最终反应为被一次智能合约执行时，一个EVM实例会基于当前正在创建的区块信息和当前这个交易的信息被初始化出来。具体地说，就是将调用合约账户所对应的代码加载到ROM中，程序计数器记为0，从调用合约的合约账户的存储中加载存储数据，将内存清零并将与区块和其他环境变量相关的信息设置好。这个执行中的关键变量就是提供给这次执行的gas，这个gas被设定为原始交易开始时由交易发送者支付的gas总量。在执行过程中，gas的值会随着操作的消耗而减少，当gas的供给不足时，会抛出一个“out of gas”的异常，执行的交易会立即停止，除了对交易者的随机数Nonce加1并且从其账户中扣除已经消耗的gas费用之外，其余所有变动都不会反应到以太坊的状态中，然后EVM会按照合约字节码的顺序执行OPCODE，每次执行OPCODE过程中分配适合该指令的stack和memory，stack和memory并且每执行一个OPCODE就更新Memory中的状态以及gas值中减去OPCODE消耗的gas费用。因为智能合约可以相互调用，因此代码的执行是一个递归的过程。一个合约可以调用其它合约，每次调用都会最终反应为另一个基于新目标的EVM执行。EVM执行的模型如下图所示：

![img](file:///C:/Users/czm18/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif)

 

**可行性分析**

由于go-ethereum已经使用go重写了以太坊的客户端，go-ethereum/core/vm目录下有EVM详细的代码和EVM执行transaction的过程。在第一个阶段首先熟悉EVM的原理，理解EVM执行transaction的过程，根据go-ethereum中EVM的代码搭建一个在本地执行transaction的EVM虚拟机，并且在执行transaction的同时抽取交易运行的中间数据存储到本地csv。由于有目录go-ethereum/core/vm下面的代码作为参考，这样做是可行的。由于在本地EVM执行transaction抽取中间数据会导致执行效率比较低，因此在优化本地EVM方面的工作是本课题研究的重点之一。

由于EVM抽取出来的中间状态数据数据量非常大(TB级别)，当前在数据库查询优化方面有很多方法，分库和分表，数据的水平切分和垂直切分等技术，后面会对导出的数据进行分析，结合实际采用以上对数据查询进行优化。

综上所述，该实验方案具备可行性。