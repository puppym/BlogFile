### vector 扩容

push_back的话，一般来说，都是按两倍来扩容，因为push_back每次都是只插入一个数据

insert的话，因为可以一次插入多个数据，所以要复杂一些。

触发扩容时，如果要插入的数据量比旧容量小，则按两倍扩容；如果要插入的数据量比原来的旧容量还要大，即表示即使按两倍扩容了，依然存不下要插入的数据，此时将会按照旧容量加要插入的数据量来扩容，保证一次扩容就能容下要插入的数据；

即 new_capacity = max ( old_capacity * 2, n + old_capacity )。



### select 

你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 
这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。
这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式。

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
　　（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。
　　（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
　　（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
　　（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
　　（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
　　与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

### poll

poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。   



### epoll

epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)。LT模式是默认模式，LT模式与ET模式的区别如下：

*LT模式*：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。确保数据不会丢失，鲁棒性更好。

*ET模式*：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。可能会遗漏一些数据，但是少一些系统调用。



## LT和ET

epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：

　　LT模式：**当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。**

　　ET模式：**当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。**

　　**ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。**



ET本身并不会造成饥饿，由于事件只通知一次，开发者一不小心就容易遗漏了待处理的数据，像是饥饿，实质是bug
使用ET模式，特定场景下会比LT更快，因为它可以便捷的处理EPOLLOUT事件，省去打开与关闭EPOLLOUT的epoll_ctl（EPOLL_CTL_MOD）调用。从而有可能让你的性能得到一定的提升。
例如你需要写出1M的数据，写出到socket 256k时，返回了EAGAIN，ET模式下，当再次epoll返回EPOLLOUT事件时，继续写出待写出的数据，当没有数据需要写出时，不处理直接略过即可。而LT模式则需要先打开EPOLLOUT，当没有数据需要写出时，再关闭EPOLLOUT（否则会一直返回EPOLLOUT事件）
总体来说，ET处理EPOLLOUT方便高效些，LT不容易遗漏事件、不易产生bug
如果server的响应通常较小，不会触发EPOLLOUT，那么适合使用LT，例如redis等。而nginx作为高性能的通用服务器，网络流量可以跑满达到1G，这种情况下很容易触发EPOLLOUT，则使用ET。
关于某些场景下ET模式比LT模式效率更好，我有篇文章进行了详细的解释与测试，参看
[epoll LT/ET 深入剖析](https://link.zhihu.com/?target=http%3A//blog.csdn.net/dongfuye/article/details/50880251)
这里有两个例子，分别演示了LT与ET两种工作模式
[handy/epoll-et.cc at master · yedf/handy · GitHub](https://link.zhihu.com/?target=https%3A//github.com/yedf/handy/blob/master/raw-examples/epoll-et.cc)
[handy/epoll.cc at master · yedf/handy · GitHub](https://link.zhihu.com/?target=https%3A//github.com/yedf/handy/blob/master/raw-examples/epoll.cc)

https://www.zhihu.com/question/20502870

### 同步是阻塞模式，异步是非阻塞模式。

同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；

异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。

### 进程和线程的区别

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。**但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。**

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。**这就是进程和线程的重要区别。** **进程是资源分配的最小单位，线程是CPU调度的最小单位。**

### 大根堆和小根堆

要求的出最小的K个元素用大根堆，得出最大的K个元素用小根堆。然后每次后面的元素往堆上加即可

### linux常见端口

| 20   | ftp-data | FTP 数据端口                                           |
| ---- | -------- | ------------------------------------------------------ |
| 21   | ftp      | 文件传输协议（FTP）端口；有时被文件服务协议（FSP）使用 |
| 22   | ssh      | 安全 Shell（SSH）服务                                  |
| 23   | telnet   | Telnet 服务                                            |
| 80   | http     |                                                        |
| 443  | https    |                                                        |

### new和malloc的区别



1. **malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。**它们都可用于申请动态内存和释放内存。 

2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。  

3. 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。 

4. C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。 

5. new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void指针。  

6. malloc和free是函数，而new和delete是操作符



### C++ 空类默认的类成员函数

C++的空类有哪些成员函数：
. 缺省构造函数。
. 缺省拷贝构造函数。
. 缺省析构函数。
. 缺省赋值运算符。
. 缺省取址运算符。 `class1*operator&(){}//取址运算符`
. 缺省取址运算符 const。   `const class1*operator&()const{}//取址运算符 const`

注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。

### 构造函数、析构函数可以是虚函数么？

构造函数不能为虚函数，而析构函数可以且常常是虚函数。

### 构造函数不能是虚函数

1. 存储空间角度
    　　虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。
2. 多态角度
    　　虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。
        　　在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，没有必要成为虚函数。

### 析构函数常常是虚函数

创建一个对象时我们总是要明白指定对象的类型。虽然我们可能通过基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。
 写通用函数时，运行根据传入对象的类型确定函数的地址，然后调用该函数。但析构却不一定，上面已经提到过了，我们往往通过基类的指针来销毁对象。**这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。**



### C++中 vector、list、deque、set、map的底层实现

在STL中基本容器有: vector、list、deque、set、map

1. vector
   * vector就是动态数组.它也是在堆中分配内存,元素连续存放,有保留内存,**如果减少大小后，内存也不会释放.如果新值>当前大小时才会再分配内存.**
   * 元素的插入和删除会造成内存块的拷贝，**当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。**
   * **如果你的元素是结构或是类,那么移动的同时还会进行构造和析构操作，所以性能不高 （最好将结构或类的指针放入vector中，而不是结构或类本身，这样可以避免移动时的构造与析构)。**
2. list
   * list是双向链表，没有预留空间的习惯，每次插入一个元素都是直接仔内存中分配空间。
   * list的随机存储和访问没有效率，适合元素的删除和插入。

如果你喜欢经常添加删除大对象的话,那么请使用list
要保存的对象不大,构造与析构操作不复杂,那么可以使用vector代替
list<指针>完全是性能最低的做法,这种情况下还是使用vector<指针>好,因为指针没有构造与析构,也不占用很大内存

3. map 

map的底层是红黑树，以键值对的形式进行存储，方便进行查找。插入和删除操作都可以在O(logn)的时间内完成。



### unordered_map和map之间的比较

非频繁的查询用map比较稳定；频繁的查询用hash_map效率会高一些，c++11中的unordered_map查询效率会更高一些但是内存占用比hash_map稍微大点。unordered_map 就是 boost 里面的 hash_map 实现。

若**考虑有序，查询速度稳定，容器元素量少于1000,非频繁查询那么考虑使用map**。**若非常高频查询(100个元素以上，unordered_map都会比map快)，内部元素可非有序，数据大超过1k甚至几十万上百万时候就要考虑使用unordered_map**(元素上千万上亿时4GB的内存就要担心内存不足了,需要数据库存储过程挪动到磁盘中)。

详解

https://blog.csdn.net/batuwuhanpei/article/details/50727227

**map**

内部实现了一个红黑树，该结构具有自动排序的功能，map内部的元素都是有序的，在红黑树上的增删改查操作都是logn级别

**优点**

1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
2. 红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
3. 查询速度稳定

**缺点**

1. ~~空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间~~少量数据的情况下hashmap比map占用的内存多，map是一个萝卜一个坑，hashmap可能以后有坑没萝卜的情况存在。大量数据的情况下可能是hashmap占用的空间更少。
2. 查找平均速度低于hash_table。

适用性：对于元素顺序有要求，元素数目相对较少，查找速度恒定的场景用map更加高效一点。

**unordered_map**

**优点**

1. 内部实现hash_table，因此其查找速度非常快

**缺点**

1. 构建hash_table比较耗费时间
2. 查找时间可能不稳定，因为使用链地址法解决hash冲突，可能存在极端的情况形成单链表。

适用于对于查找速度要求比较高，数据量比较大的场景。

### 红黑树



### C的分段布局

https://www.cnblogs.com/kimiway/p/3229470.html

1. 程序代码区（.text）

（即代码段-text）存放函数体的二进制代码，代码段由程序中执行的机器代码组成。在C语言中，程序语句进行编译后，形成机器代码。在执行程序的过程中，CPU的程序计数器指向代码段的每一条机器代码，并由处理器依次运行。

2. 文字常量区（.rodata）

常量字符串就是放在这里的（即只读数据段），程序结束后由[系统](http://www.2cto.com/os/)释放(rodata—read only data)。只读数据段是程序使用的一些不会被更改的数据，使用这些数据的方式类似查表式的操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。

3. 全局区/静态区（static）

全局变量和静态变量的存储是放在一块的。初始化的全局变量和静态变量在一块区域(.rwdata or .data)（即已初始化读写数据段），未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bss)（即未初始化数据段）， 程序结束后由系统释放。已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并具有初值，以供程序运行时读写。未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。（注意：在 C++中，已经不再严格区分bss和 data了，它们共享一块内存区域。）

4. 堆区（heap）

一般由程序员分配释放(new/malloc/calloc delete/free)，若程序员不释放，程序结束时可能由操作系统回收。（注意：它与数据结构中的堆是两回事，但分配方式倒类似于链表。）

5. 栈区（stack）

由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。









Q12. 红黑树的特点以及常见的二叉平衡树

A：红黑树性能比较高，插入删除时间复杂度保持在logn。和AVL相比，要求不是那么严格，它只要求到叶节点的最长路径不超过最短路径的两倍。相比之下，AVL要求左右子树相差高度不超过一，简单的插入或者删除都会导致树的不平衡需要旋转操作。



A：c++空类的大小为1，如果含有虚函数的话，大小为指针的大小。32位系统指针大小是4。c++要求即使是空类，对象也要有存储空间。含有虚函数的空类则是因为对象由虚函数指针。



Q24. 常见Linux命令是否用过，比如strace和netstat

A：这个有用过，strace用来跟踪程序的执行，top查看内存，以及tcpdump等进行抓包等等。