1. 了解哪几种排序方式？有没有 O(n) 的排序  
对于是否有O(n)时间复杂度的排序算法，虽然前面基于比较排序的下限是O(nlgn)，但是确实也有线性时间复杂度的排序，不过有前提条件，就是带排序的数要满足一定范围的整数，并且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数，然后依次输出即可得到有序序列。

    冒泡排序: O(n^2)
    插入排序: O(n^2)
    选择排序: O(n^2)
    希尔排序: O(n^1.3)希尔排序使插入排序的一种高效实现，也叫缩小增量排序
    快速排序：O(nlgn)
    归并排序：O(nlgn)归并排序采用递归分治的思想，先递归划分子问题，然后合并结果。把待排序序列看成有两个有序子序列，合并两个子序列。(大容量数据进行排序)
    堆排序：O(nlgn)分为大根堆和小根堆(寻找前K个元素)，调整堆的级别是O(lgn)
    桶排序：O(nlgn)在每个桶只有一个数据的情况下达到最好为O(n)
    基数排序：O(dn)不需要进行记录关键字之间的比较，基数排序是一种借助多关键字排序思想对但逻辑关键字进行排序的方法，所谓的多关键字就是有多个优先级不同的关键字。比如数字的个十百千位分别按照字符串的到校进行比较。

稳定排序：基数排序，归并排序，插入排序，冒泡排序
https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%2010%20%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.md

2. 平衡二叉树(AVL树)的插入
https://blog.csdn.net/jyy305/article/details/70949010
平衡二叉树的提出就是保证二叉查找树树不至于太倾斜，尽量保证两边平衡，定义：
    1. 平衡二叉树要么是一颗空树
    2. 要么保证左右子树的高度差不大于一
    3. 子树也是有个平衡二叉树
旋转分为LL，RR，(方向相反)，LR，RL(方向相同，先左旋，再右旋)


3. 二叉查找树
根结点比左子树所有结点都要大，比右子树所有结点都要小

4. 10个 G 的最高访问 Ip 统计 
https://blog.csdn.net/v_JULY_v/article/details/6279498
https://blog.csdn.net/zyq522376829/article/details/47686867
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 
2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 
3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；
4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；

返回频度最高的100个：对于海量数据通过hash来进行分组，然后对每个分组进行计算，将每个分组计算的结果进行合并。
对大文件进行排序： 首先将一个大文件通过hash函数(hash(key)mod 10)分成多个小文件，然后对多个小文件的内部使用快速排序，最后将10个排序后的文件使用外部和内部的归并排序。
对于大文件还能采用bitmap来进行处理，使用位图法来判断整型数组是否重复
一般使用hash_map，红黑树来统计次数，使用最高的K个数一般使用堆排序。

5. 倒排索引
http://www.cnblogs.com/zlslch/p/6440114.html
正向索引的结构如下：
doc1->word1->word2->word3
doc2->word1->word2
doc3->word1
一般是通过key去找value
当用户在主页上搜索关键字“华为手机，假设只存在正向索引，那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据模型打分，排除名次后呈现给用户。因为互联网上收录引擎中的文档数量是一个天文数字，这样的索引结构根本就无法满足实时返回排名结果的要求。
所以搜索引擎会将正向索引重新构建为倒排索引，即把文件ID对用的关键字转换为关键词到文件ID的映射，每个关键字都对应着一系列的文件
word1->doc1->doc2->doc3
word2->doc1->doc2
单词词典的实现常用的数据结构包括哈希加链表结构和树形词典结构。

6. 常用缓存置换算法
FIFO：先进先出，如果一个数据最先进入缓存，则应该最早淘汰。
LFU（Least Frequently Used）：最近最少未使用，如果一个数据在最近一段时间内使用的次数很少，那么在将来一段时间内被使用的可能性也很小。
LRU：最近最久未使用，如果一个数据在最近一段时间内都没有被访问到，那么在将来它被访问的可能性也很小。

7. Lru 算法的实现及优化
http://www.cnblogs.com/dolphin0520/p/3741519.html
实现可以采用链表加hash_map，当需要插入新的数据项的时候，如果新的数据项在链表中存在(命中)，则报该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表的头部，否则返回-1.这样一来就在链表尾部节点就是最近最久未访问的数据项。
但是这样有缺点，在删除尾节点的时候需要遍历整个链表O(n)，因此对于此的优化可以采用双向链表来进行优化。

8. 堆和栈的区别
所处位置不同，存储的变量生命周期不同

9. 常用 hash 
MD5： 输入使512位分组，输出是4个32位字的级联。MD5比MD4来的复杂，而且速度较之要慢一点，但是更安全，在抗分析和抗差分方面表现更好。
SHA-1：对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举性更好，HA-1 设计时基于和MD4同样原理,而且模仿了该算法。
SHA-2：
应用：文件校验，数字签名

10. md5、sha1 的实现

11. 一万个 url 的快速查找
用hash_map存储

12. 两个有序数组找并集的优化
和合并两个有序数组相同，较小的数下标加加，如果两个数大小相同，存入新的容器，然后同时++；

13. 10亿个整数中找最大的 100 个，用 O(n)
使用最小堆
https://blog.csdn.net/zyq522376829/article/details/47686867