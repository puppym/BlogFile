1. **DAG和交易并行执行的关系。**

   https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/3_features/31_performance/dag-based_parallel_transaction_execution_engine.html

2. **pos挖矿具体的工作过程。**

3. **后台执行的2中方式，staf工具后台执行shell命令的原理。**

   linux 后台执行的方法:

   1. 在代码里面显示的指定-d参数
   2. 再命令后面使用&   `command  >  out.file  2>&1  & `
   3. 使用nohup命令  `nohup command > myout.file 2>&1 &`

4. **kill -9  -9是指啥**  

   kill -term PPID   term是一个term信号  https://blog.csdn.net/weixin_35120567/article/details/113394496

   1.一般使用：kill -n 进程号   例(kill -15 123456、kill -9 123456)

   2.杀死指定用户所有进程  kill -u 用户名

   说明：一般情况下不要使用kill -9，因为它没有给进程留下善后的机会：

   1) 关闭socket链接

   2) 清理临时文件

   3) 将自己将要被销毁的消息通知给子进程

   4) 重置自己的终止状态

5. **go map是否线程安全**

   普通的map不是线程安全的，sync.map是线程安全的，具体实现参考了java的concurrenthashmap

   https://colobu.com/2017/07/11/dive-into-sync-Map/

6. **goroutine和普通线程的区别**

7. **函数指针和函数对象**

   **1.函数指针**
   函数指针：是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。函数指针主要由以下两方面的用途：调用函数和用作函数参数。

   函数指针的声明方法
   数据类型标志符 （指针变量名） （形参列表）； 
   一般函数的声明为:  
   int func ( int x ); 
   而一个函数指针的声明方法为： 
   int (*func) (int x); 
   前面的那个(*func)中括号是必要的，这会告诉编译器我们声明的是函数指针而不是声明一个具有返回型为指针的函数，后面的形参要视这个函数指针所指向的函数形参而定。

   **2.函数对象**

   C++函数对象实质上是操作符重载，实现了对()操作符的重载。C++函数对象不是函数指针。但是，在程序代码中，它的调用方式与函数指针一样，后面加个括号就可以了。

   **3.C++11 function函数对象**
   介绍：类模版std::function是一种通用、多态的函数封装。std::function可以对任何可以调用的实体进行封装，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。 
   通常std::function是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。std::function使用 模板转换构造函数接收被包装的函数对象；特别是，闭包类型可以隐式地转换为std::function。 
   也就是说，通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象；让我们不再纠结那么多的可调用实体。一切变的简单粗暴。
   https://blog.csdn.net/u012677715/article/details/79252163

1. **pbft和pow的区别，pbft是否分叉？如何解决分叉？**

   Prepare包合法性判断：主要判断是否是重复的Prepare包、Prepare请求中包含的区块父哈希是否是当前节点最高块哈希(防止分叉)、Prepare请求中包含区块的块高是否等于最高块高加一；

   https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/consensus/pbft.html

2. **evm 修改世界状态如何写入到一个分布式系统中。写一个value值的时候可能需要RPC调用多次。**

   1. 多叉的MPT树降低树的高度。
   2. 减少RPC通讯量。

3. **零知识证明项目**

4. **比特币网络如何动态调整当前的挖矿难度**

   比特币网络的难度值是不断变化的，它的难度值保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，说明全网算力增加，难度值也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度值也会减少。因此，难度值随着全网算力的增减会动态调整。

5. **矿工获得的奖励是包含在哪里的**

   为什么区块可以安全广播？因为Merkle Hash锁定了该区块的所有交易，而该区块的第一个coinbase交易输出地址是该矿工地址。每个矿工在挖矿时产生的区块数据都是不同的，所以无法窃取别人的工作量。

13. CAP系统

    - Consistency   一致性

    - Availability  高可用

    - Partition tolerance 分区容错性

      - **一致性（Consistency）**：每次读取要么获得最近写入的数据，要么获得一个错误。
      - **可用性（Availability）**：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据。
      - **分区容忍（Partition tolerance）**：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。

      CAP 定理表明，在存在网络分区的情况下，一致性和可用性必须二选一。**当网络发生分区（不同节点之间的网络发生故障或者延迟较大）时，要么失去一致性（允许不同分区的数据写入），要么失去可用性（识别到网络分区时停止服务）。**而在没有发生网络故障时，即分布式系统正常运行时，一致性和可用性是可以同时被满足的。这里需要注意的是，CAP 定理中的一致性与 ACID 数据库事务中的一致性截然不同。ACID 的 C 指的是事务不能破坏任何数据库规则，如键的唯一性。与之相比，CAP 的 C 仅指单一副本这个意义上的一致性，因此只是 ACID 一致性约束的一个严格的子集。

      CAP 理论看起来难理解，其实只要抓住一个核心点就能推导出来，不用死记硬背。在出现网络分区的时候，

      - 如果系统不允许写入，那么意味着降低了系统的可用性，但不同分区的数据能够保持一致，即选择了一致性。
      - 如果系统允许写入，那么意味着不同分区之间的数据产生不一致，系统可用性得到保障，即选择可用性。

    https://blog.xiaohansong.com/cap-theorem.html

    https://www.ruanyifeng.com/blog/2018/07/cap.html